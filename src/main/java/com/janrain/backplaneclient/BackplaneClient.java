package com.janrain.backplaneclient;

import org.apache.commons.httpclient.HttpClient;
import org.apache.commons.httpclient.HttpException;
import org.apache.commons.httpclient.HttpMethod;
import org.apache.commons.codec.binary.Base64;
import org.apache.commons.httpclient.methods.GetMethod;
import org.apache.commons.httpclient.methods.PostMethod;
import org.apache.log4j.ConsoleAppender;
import org.apache.log4j.Level;
import org.apache.log4j.Logger;
import org.apache.log4j.PatternLayout;
import org.codehaus.jackson.map.ObjectMapper;
import org.codehaus.jackson.type.TypeReference;
import java.io.BufferedInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.net.MalformedURLException;
import java.net.URL;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;


/**
 * @author Tom Raney
 */
public class BackplaneClient {

    private ClientCredentials clientCredentials;
    private final int TIMEOUT = 5000;
    private static final Logger logger = Logger.getLogger(BackplaneClient.class);

    /**
     * Initialize client.
     *
     * @param clientCredentials
     * @param initializeToken
     * @param scope
     * @throws UnauthorizedScopeException
     * @throws BackplaneClientException
     */
    public BackplaneClient(ClientCredentials clientCredentials, boolean initializeToken, String scope)
            throws UnauthorizedScopeException, BackplaneClientException {

        this.clientCredentials = clientCredentials;

        if (initializeToken) {
            this.clientCredentials.setAccessToken(getNewToken(scope));
        }
    }


    public ClientCredentials getClientCredentials() {
        return clientCredentials;
    }

    /**
     * Refresh the access token attached to the ClientCredentials object
     *
     * If the scope argument is a subset of the original access token scope, the returned access token
     * will be limited to the new scope.  It is not possible during token refresh to request a scope that
     * is not a subset of the original scope.
     *
     * @param scope
     * @throws UnauthorizedScopeException
     * @throws BackplaneClientException
     */

    public void refreshToken(String scope)
            throws UnauthorizedScopeException, BackplaneClientException {
        clientCredentials.setAccessToken(AccessTokenManager.refreshAccessToken(clientCredentials, scope));
    }

    /**
     * Get an access token using client credentials.  If a scope value is
     * provided for a particular bus, in the form "bus:foo" then the token returned will be limited to the
     * requested scope, even if the client has additional grants available.  By submitting a null value for scope,
     * a "super" token will be returned, encompassing all grants currently available for the client.
     *
     * @param scope
     * @return AccessToken object
     * @throws UnauthorizedScopeException
     * @throws BackplaneClientException
     */
    public AccessToken getNewToken(String scope)
            throws UnauthorizedScopeException, BackplaneClientException {
        return AccessTokenManager.getAccessToken(clientCredentials, scope);
    }

    /**
     * Get a regular access token.  This method will return an access token with a scope limited to the
     * provided bus and server generated channel name.  This endpoint is normally used for client side user-agent code
     * during Backplane initialization, but is useful here because it is only possible to post against a channel
     * that has been generated by the server.
     *
     * @param bus
     * @return AccessToken object
     * @throws BackplaneClientException
     * @throws UnauthorizedScopeException
     */

    public AccessToken getRegularAccessToken(String bus)
            throws BackplaneClientException, UnauthorizedScopeException {
        return AccessTokenManager.getRegularAccessToken(clientCredentials.getBackplaneServerUrl(), bus);
    }

    /**
     * Post a message.
     *
     * @param message
     * @throws ExpiredTokenException
     * @throws InvalidTokenException
     * @throws BackplaneClientException
     */

    public void postMessage(BackplaneMessage message)
            throws ExpiredTokenException, InvalidTokenException, BackplaneClientException {

        HttpClient httpClient = getHttpClient();

        PostMethod httpMethod = new PostMethod(clientCredentials.getBackplaneServerUrl() + "/v2/message");
        httpMethod.addRequestHeader("Authorization", "Bearer " + clientCredentials.getAccessToken().getAccess_token());
        httpMethod.addRequestHeader("Content-type", "application/json");

        try {
            Map<String, BackplaneMessage> map = new HashMap<String, BackplaneMessage>();
            map.put("message", message);
            String jsonBody = new ObjectMapper().writeValueAsString(map);
            logger.debug("jsonBody: " + jsonBody);
            httpMethod.setRequestBody(jsonBody);
        } catch (IOException e) {
            e.printStackTrace();
        }

        String response = AccessTokenManager.makeCall(httpClient, httpMethod);

        if (httpMethod.getStatusCode() != 201) {
            logger.warn("message did not post");
            if (response.contains("expired token")) {
                throw new ExpiredTokenException();
            } else if (response.contains("invalid token")) {
                throw new InvalidTokenException();
            } else {
                throw new BackplaneClientException();
            }
        }

        logger.info("message posted");
        return;

    }

    public BackplaneMessage getSingleMessage(String messageId)
            throws BackplaneClientException, InvalidTokenException, ExpiredTokenException {
        try {
            return getSingleMessage(new URL(clientCredentials.getBackplaneServerUrl() + "/v2/message/" + messageId));
        } catch (MalformedURLException e) {
            throw new BackplaneClientException(e.getMessage());
        }
    }

    /**
     * Retrieve a single message body
     * @param messageUrl
     * @return
     * @throws BackplaneClientException
     */

    public BackplaneMessage getSingleMessage(URL messageUrl)
            throws BackplaneClientException, ExpiredTokenException, InvalidTokenException {

        HttpClient httpClient = getHttpClient();

        HttpMethod httpMethod = new GetMethod(messageUrl.toString());
        httpMethod.addRequestHeader("Authorization", "Bearer " + clientCredentials.getAccessToken().getAccess_token());
        BufferedInputStream bis = null;

        String response = AccessTokenManager.makeCall(httpClient, httpMethod);

        if (httpMethod.getStatusCode() != 200) {
            logger.warn("call failed: " + response);
            if (response.contains("expired token")) {
                throw new ExpiredTokenException();
            } else if (response.contains("invalid token")) {
                throw new InvalidTokenException();
            } else {
                throw new BackplaneClientException();
            }
        } else {
            try {
                return new ObjectMapper().readValue(response, new TypeReference<BackplaneMessage>() {});
            } catch (IOException e) {
                throw new BackplaneClientException(e.getMessage());
            }
        }
    }

    /**
     * Call the Backplane server and retrieve all messages in the scope of the access token.
     *
     * This method will *not* loop and retrieve all messages.  It is up to the caller of this method to
     * use the returned MessageWrapper object and the isMoreMessages() method to determine if additional
     * calls are required to retrieve all messages known to be available at the time the call was made.
     *
     * The Backplane server will only return a maximum of N messages per call - N being defined
     * by the particular server deployment.
     *
     * @param messageWrapper (may be null)
     * @param block (may be null) how long to block in seconds while waiting for messages
     * @return MessageWrapper object that contains an array of messages.
     */

    public MessageWrapper getMessages(MessageWrapper messageWrapper, Integer block)
            throws ExpiredTokenException, InvalidTokenException, BackplaneClientException {

        HttpClient httpClient = getHttpClient();

        String url = clientCredentials.getBackplaneServerUrl() + "/v2/messages";

        if (messageWrapper != null) {
            url = messageWrapper.getNextURL();
        }

        if (block != null) {
            logger.debug("long polling for up to " + block + " seconds");
            if (messageWrapper != null) url += "&block=" + block;
            else url += "?block=" + block;
            // make sure the connection doesn't time out during long poll
            httpClient.getHttpConnectionManager().getParams().setSoTimeout((block*1000)+TIMEOUT);
        }

        HttpMethod httpMethod = new GetMethod(url);
        httpMethod.addRequestHeader("Authorization", "Bearer " + clientCredentials.getAccessToken().getAccess_token());

        String response = AccessTokenManager.makeCall(httpClient, httpMethod);

        if (httpMethod.getStatusCode() != 200) {
            logger.warn("call failed: " + response);
            if (response.contains("expired token")) {
                throw new ExpiredTokenException();
            } else if (response.contains("invalid token")) {
                throw new InvalidTokenException();
            } else {
                throw new BackplaneClientException();
            }
        } else {
            logger.debug(response);
            try {
                return new ObjectMapper().readValue(response, new TypeReference<MessageWrapper>() {});
            } catch (IOException e) {
                throw new BackplaneClientException(e.getMessage());
            }
        }
    }

    public String retrieveChannelFromScope(String scope) {
        int index = scope.indexOf("channel:");
        return scope.substring(index+8);
    }

    private HttpClient getHttpClient() {
        HttpClient httpClient = new HttpClient();
        httpClient.getHttpConnectionManager().getParams().setSoTimeout(TIMEOUT);
        httpClient.getHttpConnectionManager().getParams().setConnectionTimeout(TIMEOUT);
        return httpClient;
    }


}
